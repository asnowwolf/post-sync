# 技术栈参考文档

本文档旨在为 `post-sync` 项目提供核心技术栈的 API 摘录和代码范例，以减少在开发过程中对外部文档的依赖。

---

## 1. `ts-node` - TypeScript 执行器

- **版本**: v10.9.2 (LTS)
- **文档**: [https://www.npmjs.com/package/ts-node](https://www.npmjs.com/package/ts-node)
- **项目用途**: 在开发环境中直接执行 TypeScript 编写的 CLI 工具，无需预先编译，以支持 `npm link` 等工作流。

### 范例: `package.json` 与 Shebang

**`package.json` 配置:**

```json
{
  "name": "post-sync",
  "version": "1.0.0",
  "bin": {
    "post-sync": "src/index.ts"
  },
  "scripts": {
    "start": "ts-node src/index.ts"
  }
}
```

**`src/index.ts` 文件 Shebang:**

```typescript
#!/usr/bin/env ts-node

console.log("CLI tool is running!");
// ... CLI a.ts代码
```

---

## 2. `commander` - CLI 框架

- **版本**: v11.1.0 (LTS)
- **文档**: [https://www.npmjs.com/package/commander](https://www.npmjs.com/package/commander)
- **项目用途**: 构建 `post-sync` 的命令行接口，定义 `create`, `publish`, `clean` 等子命令及其参数。

### 范例: CLI 结构

```typescript
// src/index.ts
#!/usr/
bin / env
ts - node
import {Command} from 'commander';

const program = new Command();

program
    .name('post-sync')
    .description('一个将 Markdown 文件发布到微信公众号的 CLI 工具')
    .version('1.0.0');

program
    .command('create <path>')
    .description('读取文件或目录，并创建一篇或多篇公众号草稿')
    .option('--appId <id>', '微信公众号的 AppID')
    .option('--appSecret <secret>', '微信公众号的 AppSecret')
    .option('--proxy <url>', '网络请求代理')
    .action((path, options) => {
        console.log(`'create' command called for path: ${path}`);
        // ... create 命令的实现
    });

program
    .command('publish <path>')
    .description('发布一篇或多篇已创建的草稿')
    .action((path) => {
        console.log(`'publish' command called for path: ${path}`);
        // ... publish 命令的实现
    });

program
    .command('clean')
    .description('清理 .ps 目录下的临时文件')
    .action(() => {
        console.log(`'clean' command called`);
        // ... clean 命令的实现
    });

program.parse(process.argv);
```

---

## 3. `better-sqlite3` - SQLite 驱动

- **版本**: v9.2.2 (LTS)
- **文档**: [https://www.npmjs.com/package/better-sqlite3](https://www.npmjs.com/package/better-sqlite3)
- **项目用途**: 在 `.ps/db.sqlite` 文件中创建和管理本地数据库，用于持久化文章、草稿和发布的元数据。

### 范例: 数据库服务

```typescript
// src/services/db.service.ts
import Database from 'better-sqlite3';
import * as path from 'path';
import * as fs from 'fs';

const dbPath = path.resolve('.ps', 'db.sqlite');

export class DbService {
    private db: Database.Database;

    constructor() {
        // 确保 .ps 目录存在
        fs.mkdirSync(path.dirname(dbPath), {recursive: true});

        this.db = new Database(dbPath);
        this.init();
    }

    private init() {
        const createTablesStm = `
      CREATE TABLE IF NOT EXISTS articles (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        source_path TEXT UNIQUE,
        source_hash TEXT,
        created_at TEXT,
        updated_at TEXT
      );
      -- 其他表的创建语句...
    `;
        this.db.exec(createTablesStm);
    }

    public findArticleByPath(sourcePath: string) {
        const stm = this.db.prepare('SELECT * FROM articles WHERE source_path = ?');
        return stm.get(sourcePath);
    }

    public insertArticle(sourcePath: string, hash: string) {
        const stm = this.db.prepare(
            'INSERT INTO articles (source_path, source_hash, created_at, updated_at) VALUES (?, ?, ?, ?)'
        );
        const now = new Date().toISOString();
        return stm.run(sourcePath, hash, now, now);
    }

    // 推荐：将所有写操作包装在事务中
    public performTransaction(callback: () => void) {
        const transaction = this.db.transaction(callback);
        transaction();
    }
}
```

---

## 4. `marked` & `highlight.js` - Markdown 解析与高亮

- **`marked` 版本**: v11.1.1 (LTS)
- **`highlight.js` 版本**: v11.9.0 (LTS)
- **文档**: [https://marked.js.org/](https://marked.js.org/), [https://highlightjs.org/](https://highlightjs.org/)
- **项目用途**: 将 Markdown 文本转换为 HTML，并对其中的代码块进行语法高亮。

### 范例: 自定义转换器

```typescript
// src/services/markdown.service.ts
import {marked, Renderer} from 'marked';
import hljs from 'highlight.js';

export class MarkdownService {
    constructor() {
        marked.setOptions({
            renderer: new Renderer(),
            highlight: (code, lang) => {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                return hljs.highlight(code, {language}).value;
            },
            gfm: true,
            breaks: false,
            pedantic: false
        });
    }

    public async convert(markdown: string): Promise<string> {
        // 示例：拦截和处理图片
        const renderer = new Renderer();
        renderer.image = (href, title, text) => {
            // 在这里，href 是图片 URL
            // TODO: 实现图片上传并替换 href 的逻辑
            const newHref = `https://mmbiz.qpic.cn/sz_mmbiz_jpg/...`; // 替换为上传后的 URL
            return `<img src="${newHref}" alt="${text}" title="${title || ''}" />`;
        };

        // 注意：在实际应用中，图片处理需要异步，
        // marked 的同步 API 需要通过 walkTokens 等方式进行更复杂的处理。
        // 这里为了简化范例，只展示了 renderer 的用法。

        return marked(markdown, {renderer});
    }
}
```

---

## 5. `sharp` - 图片处理

- **版本**: v0.33.1 (LTS)
- **文档**: [https://sharp.pixelplumbing.com/](https://sharp.pixelplumbing.com/)
- **项目用途**: 在上传前对图片进行处理，如调整尺寸、裁剪或压缩，并将结果输出为 Buffer。

### 范例: 图片缩放

```typescript
// src/utils/image.util.ts
import sharp from 'sharp';
import fs from 'fs/promises';

export async function resizeImage(inputPath: string): Promise<Buffer> {
    const imageBuffer = await fs.readFile(inputPath);

    // 示例：将图片宽度调整为 1080px，高度自动缩放
    return sharp(imageBuffer)
        .resize({width: 1080})
        .jpeg({quality: 80}) // 转换为 jpeg 并设置质量
        .toBuffer();
}
```

---

## 6. `axios` & `form-data` - HTTP 请求

- **`axios` 版本**: v1.6.5 (LTS)
- **`form-data` 版本**: v4.0.0 (LTS)
- **文档
  **: [https://axios-http.com/](https://axios-http.com/), [https://www.npmjs.com/package/form-data](https://www.npmjs.com/package/form-data)
- **项目用途**: 调用微信公众号 API，特别是上传图片等需要 `multipart/form-data` 格式的请求。

### 范例: 上传图片

```typescript
// src/services/wechat.service.ts
import axios from 'axios';
import FormData from 'form-data';
import {Stream} from 'stream';

// 假设 imageBuffer 是 sharp 处理后得到的图片 Buffer
async function uploadImage(accessToken: string, imageBuffer: Buffer): Promise<string> {
    const form = new FormData();
    // 将 Buffer 转换为可读流
    const stream = Stream.Readable.from(imageBuffer);
    form.append('media', stream, {filename: 'image.jpg', contentType: 'image/jpeg'});

    const url = `https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=${accessToken}`;

    try {
        const response = await axios.post(url, form, {
            headers: form.getHeaders(),
        });

        if (response.data.errcode) {
            throw new Error(`WeChat API Error: ${response.data.errmsg}`);
        }

        return response.data.url;
    } catch (error) {
        // ... 错误处理
        throw error;
    }
}
```

---

## 7. `crypto` - 文件哈希

- **版本**: Node.js 内置
- **文档**: [https://nodejs.org/api/crypto.html](https://nodejs.org/api/crypto.html)
- **项目用途**: 计算 Markdown 文件的 MD5 哈希值，用于检测文件内容是否发生变化。

### 范例: 计算文件 MD5

```typescript
// src/utils/file.util.ts
import * as crypto from 'crypto';
import * as fs from 'fs';

export function getFileHash(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
        const hash = crypto.createHash('md5');
        const stream = fs.createReadStream(filePath);

        stream.on('data', (data) => {
            hash.update(data);
        });

        stream.on('end', () => {
            resolve(hash.digest('hex'));
        });

        stream.on('error', (err) => {
            reject(err);
        });
    });
}
```

---

## 8. 微信公众号 API 概述

- **文档入口**: https://developers.weixin.qq.com/doc/offiaccount/Basic_Account_Info/The_restriction_of_API_calling.html
- **订阅号文档**：https://developers.weixin.qq.com/doc/subscription/api/
- **服务号文档**：https://developers.weixin.qq.com/doc/service/api/
- **项目用途**: 调用微信公众号接口，实现文章创建、上传图片、发布等功能。

### 获取 `access_token` (稳定版)

- **URL**: `https://api.weixin.qq.com/cgi-bin/stable_token`
- **方法**: `POST`
- **说明**: 推荐使用稳定版 `access_token`，具有更高的调用频率限制和更平滑的过渡机制。`access_token` 有效期最长为 7200
  秒，平台会在到期前 5 分钟提前更新。

```typescript
// src/services/wechat.api.service.ts
import axios from 'axios';

export async function getAccessToken(appId: string, appSecret: string, forceRefresh: boolean = false): Promise<string> {
    const url = `https://api.weixin.qq.com/cgi-bin/stable_token`;
    const data = {
        grant_type: 'client_credential',
        appid: appId,
        secret: appSecret,
        force_refresh: forceRefresh
    };
    const response = await axios.post(url, data);
    if (response.data.errcode) {
        throw new Error(`WeChat API Error: ${response.data.errmsg}`);
    }
    return response.data.access_token;
}
```

### 上传临时素材 (图片、语音、视频、缩略图)

- **URL**: `https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE`
- **方法**: `POST` (需 `multipart/form-data`)
- **说明**: 上传的媒体文件会保存在微信服务器，可用于发布图文消息等。`type` 可选 `image`, `voice`, `video`, `thumb`。

```typescript
// src/services/wechat.api.service.ts
// 假设 imageBuffer 是图片 Buffer
import FormData from 'form-data';
import {Stream} from 'stream';

export async function uploadTemporaryMedia(accessToken: string, type: 'image' | 'voice' | 'video' | 'thumb', mediaBuffer: Buffer, filename: string, contentType: string): Promise<string> {
    const form = new FormData();
    form.append('media', Stream.Readable.from(mediaBuffer), {filename, contentType});

    const url = `https://api.weixin.qq.com/cgi-bin/media/upload?access_token=${accessToken}&type=${type}`;

    const response = await axios.post(url, form, {
        headers: form.getHeaders(),
    });

    if (response.data.errcode) {
        throw new Error(`WeChat API Error: ${response.data.errmsg}`);
    }
    return response.data.media_id; // 返回 media_id
}
```

### 上传图文消息内的图片

- **URL**: `https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=ACCESS_TOKEN`
- **方法**: `POST` (需 `multipart/form-data`)
- **说明**: 专门用于上传图文消息正文内的图片，获取图片 `URL`，该 URL 可直接在微信文章中使用。

```typescript
// src/services/wechat.api.service.ts
// 假设 imageBuffer 是图片 Buffer
import FormData from 'form-data';
import {Stream} from 'stream';

export async function uploadArticleImage(accessToken: string, imageBuffer: Buffer, filename: string, contentType: string): Promise<string> {
    const form = new FormData();
    form.append('media', Stream.Readable.from(imageBuffer), {filename, contentType});

    const url = `https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=${accessToken}`;

    const response = await axios.post(url, form, {
        headers: form.getHeaders(),
    });

    if (response.data.errcode) {
        throw new Error(`WeChat API Error: ${response.data.errmsg}`);
    }
    return response.data.url; // 返回图片 URL
}
```

### 新建草稿 (订阅号)

- **URL**: `https://api.weixin.qq.com/cgi-bin/freepublish/add_draft?access_token=ACCESS_TOKEN`
- **方法**: `POST`
- **说明**: 为订阅号创建一篇新的图文草稿。`content` 字段是文章的 HTML 内容。

```typescript
// src/services/wechat.api.service.ts
export async function createDraft(accessToken: string, title: string, content: string, thumb_media_id: string, author: string = '', digest: string = '', show_cover_pic: 0 | 1 = 1, need_open_comment: 0 | 1 = 1, only_fans_can_comment: 0 | 1 = 0): Promise<string> {
    const url = `https://api.weixin.qq.com/cgi-bin/freepublish/add_draft?access_token=${accessToken}`;
    const data = {
        articles: {
            title,
            content,
            thumb_media_id,
            author,
            digest,
            show_cover_pic,
            need_open_comment,
            only_fans_can_comment,
        }
    };

    const response = await axios.post(url, data);
    if (response.data.errcode) {
        throw new Error(`WeChat API Error: ${response.data.errmsg}`);
    }
    return response.data.media_id; // 返回草稿的 media_id
}
```

### 发布草稿

- **URL**: `https://api.weixin.qq.com/cgi-bin/freepublish/submit?access_token=ACCESS_TOKEN`
- **方法**: `POST`
- **说明**: 将已有的草稿发布为正式文章。

```typescript
// src/services/wechat.api.service.ts
export async function publishDraft(accessToken: string, media_id: string): Promise<string> {
    const url = `https://api.weixin.qq.com/cgi-bin/freepublish/submit?access_token=${accessToken}`;
    const data = {
        media_id,
    };

    const response = await axios.post(url, data);
    if (response.data.errcode) {
        throw new Error(`WeChat API Error: ${response.data.errmsg}`);
    }
    return response.data.publish_id; // 返回发布任务 ID
}
```

### 查询发布状态

- **URL**: `https://api.weixin.qq.com/cgi-bin/freepublish/get?access_token=ACCESS_TOKEN&publish_id=PUBLISH_ID`
- **方法**: `GET`
- **说明**: 查询发布任务的详细状态。

```typescript
// src/services/wechat.api.service.ts
export async function getPublishStatus(accessToken: string, publish_id: string): Promise<any> {
    const url = `https://api.weixin.qq.com/cgi-bin/freepublish/get?access_token=${accessToken}&publish_id=${publish_id}`;
    const response = await axios.get(url);
    if (response.data.errcode) {
        throw new Error(`WeChat API Error: ${response.data.errmsg}`);
    }
    return response.data.publish_status; // 返回发布状态信息
}
```
